/*
Meet in the middle..
Loop over all possiblities of a , b  and store them with the index that generated it
Sort the list

Then loop over all possiblities of C and D (start from the bigger D) and for each possiblity off D  and C 
check the list generated by A,B to see if the wanted value exists with different index

To generate using A,B N*n
To genetate C,D N*N
To check the existance in A,B list N*N log n

= (N*N(2+logn))
*/
#include <bits/stdc++.h>
#include <complex>
using namespace std;

#define lp(i,n) for(ll i=0; i<n; i++)
#define ll long long
#define pb push_back
#define mp make_pair

#define pii pair<int,int>
#define ff first
#define ss second
#define nl "\n"

#define EPS 1e-9
#define OO 100000000

#define on(i,n) i=i|(1<<n)
#define off(i,n) i=i& (~(1<<n))

typedef  complex<int> point;
#define X real()
#define Y imag()

#define vec(a,b) (b-a)
#define angle(a) (atan2(((a).Y),((a).X)))

#define length(a) (hypot(((a).real()),((a).imag())))
#define normalize(a) ((a)/(length(a)))

#define dotp(a,b) ((conj(a)*(b)).real())
#define crossp(a,b) ((conj(a)*b).imag())
#define same(a,b) ((dcmp(((a).X),((b).X))==0 )&& (dcmp(((a).Y),((b).Y))==0))

#define lengthSqr(a) (dp((a),(a)))

#define rotateO(p,ang) ((p)*exp(poll(0,ang)))
#define rotateA(p,ang,about)  (rotateO(vec(about,p),ang)+about)
#define reflectO(v,m)  (conj((v)/(m))*(m))

#define debugme freopen("out.txt","w",stdout)
#define endp return 0;
const double PI= acos(-1.0);
double fixAngle(double A){return A > 1 ? 1 : (A < -1 ? -1 : A);}
double dcmp(double a,double b){return fabs(a-b)<EPS?0 : a>b? 1:-1; }
int n;
vector<int> nums;
vector<pair<int,pii>> data;

void solve(){
    sort(data.begin(),data.end());
    for(int d=n-1; d>=0; d--){
        for(int c=n-1; c>=0; c--){
            if(d==c) continue;

            vector<pair<int,pii>>::iterator it=lower_bound(data.begin(),data.end(), mp(nums[d]-nums[c],mp(0,0) ) );
            vector<pair<int,pii>>::iterator it2=upper_bound(data.begin(), data.end(), mp(nums[d]-nums[c],mp(OO,OO) ) );

            while (it<it2){
                auto curr= *it;
                if(curr.ss.ff!=d && curr.ss.ss!=d)
                    if(curr.ss.ff!=c && curr.ss.ss!=c)
                    {
                        printf("%d\n",nums[d]);
                        return;
                    }

                it++;
            }

        }

    }
    printf("no solution\n");
    return;


}

int main(){

while(1){
    data.clear();
    nums.clear();
    cin>>n;
    if(!n) return 0;
    nums.resize(n); lp(i,n) cin>>nums[i];
    sort(nums.begin(),nums.end());
    lp(i,n){
        for(int j=i+1; j<n; j++){
            data.push_back({nums[i]+nums[j],{i,j}});
        }
    }



    solve();

}



}

